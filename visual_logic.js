/* eslint-disable */

/**
 * Generated by Verge3D Puzzles v.4.5.1
 * Thu, 18 Dec 2025 10:09:34 GMT
 * Prefer not editing this file as your changes may get overridden once Puzzles are saved.
 * Check out https://www.soft8soft.com/docs/manual/en/introduction/Using-JavaScript.html
 * for the information on how to add your own JavaScript to Verge3D apps.
 */
function createPL(v3d = window.v3d) {

// global variables used in the init tab
const _initGlob = {
    percentage: 0,
    output: {
        initOptions: {
            fadeAnnotations: true,
            useBkgTransp: false,
            preserveDrawBuf: false,
            useCompAssets: false,
            useFullscreen: true,
            useCustomPreloader: false,
            preloaderStartCb: function() {},
            preloaderProgressCb: function() {},
            preloaderEndCb: function() {},
        },
    },
};


// global variables/constants used by puzzles' functions
var _pGlob = {};

_pGlob.objCache = new Map();
_pGlob.fadeAnnotations = true;
_pGlob.pickedObject = '';
_pGlob.hoveredObject = '';
_pGlob.mediaElements = {};
_pGlob.loadedFile = '';
_pGlob.states = [];
_pGlob.percentage = 0;
_pGlob.openedFile = '';
_pGlob.openedFileMeta = {};
_pGlob.xrSessionAcquired = false;
_pGlob.xrSessionCallbacks = [];
_pGlob.screenCoords = new v3d.Vector2();
_pGlob.intervalTimers = {};
_pGlob.customEvents = new v3d.EventDispatcher();
_pGlob.eventListeners = [];
_pGlob.htmlElements = new Set();
_pGlob.materialsCache = new Map();
_pGlob.css3Objects = new WeakMap();

_pGlob.AXIS_X = new v3d.Vector3(1, 0, 0);
_pGlob.AXIS_Y = new v3d.Vector3(0, 1, 0);
_pGlob.AXIS_Z = new v3d.Vector3(0, 0, 1);
_pGlob.MIN_DRAG_SCALE = 10e-4;
_pGlob.SET_OBJ_ROT_EPS = 1e-8;

_pGlob.vec2Tmp = new v3d.Vector2();
_pGlob.vec2Tmp2 = new v3d.Vector2();
_pGlob.vec3Tmp = new v3d.Vector3();
_pGlob.vec3Tmp2 = new v3d.Vector3();
_pGlob.vec3Tmp3 = new v3d.Vector3();
_pGlob.vec3Tmp4 = new v3d.Vector3();
_pGlob.eulerTmp = new v3d.Euler();
_pGlob.eulerTmp2 = new v3d.Euler();
_pGlob.quatTmp = new v3d.Quaternion();
_pGlob.quatTmp2 = new v3d.Quaternion();
_pGlob.colorTmp = new v3d.Color();
_pGlob.mat4Tmp = new v3d.Matrix4();
_pGlob.planeTmp = new v3d.Plane();
_pGlob.raycasterTmp = new v3d.Raycaster(); // always check visibility

const createPzLib = ({ v3d=null, appInstance=null }) => {
    function getElement(id, isParent=false) {
        let elem;
        if (Array.isArray(id) && id[0] === 'CONTAINER') {
            if (appInstance !== null) {
                elem = appInstance.container;
            } else if (typeof _initGlob !== 'undefined') {
                // if we are on the initialization stage, we still can have access
                // to the container element
                const contId = _initGlob.container;
                elem = isParent ? parent.document.getElementById(contId)
                        : document.getElementById(contId);
            }
        } else if (Array.isArray(id) && id[0] === 'WINDOW') {
            elem = isParent ? parent : window;
        } else if (Array.isArray(id) && id[0] === 'DOCUMENT') {
            elem = isParent ? parent.document : document;
        } else if (Array.isArray(id) && id[0] === 'BODY') {
            elem = isParent ? parent.document.body : document.body;
        } else if (Array.isArray(id) && id[0] === 'QUERYSELECTOR') {
            elem = isParent ? parent.document.querySelector(id)
                    : document.querySelector(id);
        } else {
            elem = isParent ? parent.document.getElementById(id)
                    : document.getElementById(id);
        }
        return elem;
    }
        
    function getElements(ids, isParent=false) {
        const elems = [];
        if (Array.isArray(ids) && ids[0] !== 'CONTAINER' && ids[0] !== 'WINDOW'
                && ids[0] !== 'DOCUMENT' && ids[0] !== 'BODY'
                && ids[0] !== 'QUERYSELECTOR') {
            for (let i = 0; i < ids.length; i++) {
                elems.push(getElement(ids[i], isParent));
            }
        } else {
            elems.push(getElement(ids, isParent));
        }
        return elems;
    }
        
    function isObjectWorthProcessing(obj) {
        return obj.name !== '' &&
                !(obj.isMesh && obj.isMaterialGeneratedMesh) &&
                !obj.isAuxClippingMesh;
    }
        
    function getObjectByName(objName) {
        let objFound = null;
    
        // COMPAT: <4.9.0, old engine, new puzzles
        const isID = v3d.MathUtils.checkUUID ? v3d.MathUtils.checkUUID(objName) : false;
    
        const pGlobAvailable = _pGlob !== undefined;
        if (pGlobAvailable)
            objFound = _pGlob.objCache.get(objName);
    
        if (objFound && (isID ? objFound.uuid === objName : objFound.name === objName))
            return objFound;
    
        function findValidByName(obj, objName) {
            if ((isID ? obj.uuid === objName : obj.name === objName) && isObjectWorthProcessing(obj))
                return obj;
    
            for (let i = 0; i < obj.children.length; i++) {
                const child = obj.children[i];
                const object = findValidByName(child, objName);
                if (object !== null)
                    return object;
            }
    
            return null;
        }
    
        if (appInstance.scene) {
            objFound = findValidByName(appInstance.scene, objName);
            if (objFound && pGlobAvailable)
                _pGlob.objCache.set(objName, objFound);
        }
    
        return objFound;
    }
        
    function getObjectNamesByGroupName(groupName) {
        const objNameList = [];
        appInstance.scene.traverse(obj => {
            if (isObjectWorthProcessing(obj)) {
                const objGroupNames = obj.groupNames;
                if (!objGroupNames) {
                    return;
                }
    
                for (let i = 0; i < objGroupNames.length; i++) {
                    const objGroupName = objGroupNames[i];
                    if (objGroupName === groupName) {
                        objNameList.push(obj.name);
                    }
                }
            }
        });
        return objNameList;
    }
        
    function getAllObjectNames() {
        const objNameList = [];
        appInstance.scene.traverse(obj => {
            if (isObjectWorthProcessing(obj)) {
                objNameList.push(obj.name);
            }
        });
        return objNameList;
    }
        
    function retrieveObjectNamesAccum(currObjNames, namesAccum) {
        if (typeof currObjNames === 'string') {
            namesAccum.push(currObjNames);
        } else if (Array.isArray(currObjNames) && currObjNames[0] === 'GROUP') {
            const newObjNames = getObjectNamesByGroupName(currObjNames[1]);
            for (let i = 0; i < newObjNames.length; i++) {
                namesAccum.push(newObjNames[i]);
            }
        } else if (Array.isArray(currObjNames) && currObjNames[0] === 'ALL_OBJECTS') {
            const newObjNames = getAllObjectNames();
            for (let i = 0; i < newObjNames.length; i++) {
                namesAccum.push(newObjNames[i]);
            }
        } else if (Array.isArray(currObjNames)) {
            for (let i = 0; i < currObjNames.length; i++) {
                retrieveObjectNamesAccum(currObjNames[i], namesAccum);
            }
        }
    }
        
    function retrieveObjectNames(objNames) {
        const accum = [];
        retrieveObjectNamesAccum(objNames, accum);
        return accum.filter(name => name !== '');
    }
        
    function isMeshObject(obj) {
        if (obj.isMesh) {
            return true;
        }
    
        for (let i = 0; i < obj.children.length; i++) {
            const child = obj.children[i];
            if (child.isMesh && child.isMaterialGeneratedMesh) {
                return true;
            }
        }
    
        return false;
    }
        
    function areListenersSame(target0, type0, listener0, optionsOrUseCapture0,
            target1, type1, listener1, optionsOrUseCapture1) {
        const capture0 = Boolean(optionsOrUseCapture0 instanceof Object
                ? optionsOrUseCapture0.capture : optionsOrUseCapture0);
        const capture1 = Boolean(optionsOrUseCapture1 instanceof Object
                ? optionsOrUseCapture1.capture : optionsOrUseCapture1);
        return target0 === target1 && type0 === type1 && listener0 === listener1
                && capture0 === capture1;
    }
        
    function bindListener(target, type, listener, optionsOrUseCapture) {
        const alreadyExists = _pGlob.eventListeners.some(elem => {
            return areListenersSame(elem.target, elem.type, elem.listener,
                    elem.optionsOrUseCapture, target, type, listener,
                    optionsOrUseCapture);
        });
    
        if (!alreadyExists) {
            target.addEventListener(type, listener, optionsOrUseCapture);
            _pGlob.eventListeners.push({ target, type, listener,
                    optionsOrUseCapture });
        }
    }
        
    function getSceneAnimFrameRate(scene) {
        if (scene && 'animFrameRate' in scene.userData) {
            return scene.userData.animFrameRate;
        }
        return 24;
    }
        
    function getSceneByAction(action) {
        const root = action.getRoot();
        let scene = root.type === 'Scene' ? root : null;
        root.traverseAncestors(ancObj => {
            if (ancObj.type === 'Scene') {
                scene = ancObj;
            }
        });
        return scene;
    }
        
    function getMaterialEditableValues(matName) {
        const mat = v3d.SceneUtils.getMaterialByName(appInstance, matName);
        if (!mat) {
            return [];
        }
    
        if (mat.isMeshNodeMaterial) {
            return Object.keys(mat.nodeValueMap);
        } else if (mat.isMeshStandardMaterial) {
            return ['metalness', 'roughness', 'bumpScale', 'emissiveIntensity',
                    'envMapIntensity'];
        } else {
            return [];
        }
    }
        
    function transformCoordsSpace(coords, spaceFrom, spaceTo, noSignChange=false) {
    
        if (spaceFrom === spaceTo) {
            return coords;
        }
    
        const y = coords.y;
        const z = coords.z;
    
        if (spaceFrom === 'Z_UP_RIGHT' && spaceTo === 'Y_UP_RIGHT') {
            coords.y = z;
            coords.z = noSignChange ? y : -y;
        } else if (spaceFrom === 'Y_UP_RIGHT' && spaceTo === 'Z_UP_RIGHT') {
            coords.y = noSignChange ? z : -z;
            coords.z = y;
        } else {
            console.error('transformCoordsSpace: Unsupported coordinate space');
        }
    
        return coords;
    }
        
    const transformEulerV3dToBlenderShortest = function() {
        const eulerTmp = new v3d.Euler();
        const eulerTmp2 = new v3d.Euler();
        const vec3Tmp = new v3d.Vector3();
    
        return function(euler, dest) {
            const eulerBlender = eulerTmp.copy(euler).reorder('YZX');
            const eulerBlenderAlt = eulerTmp2.copy(eulerBlender).makeAlternative();
    
            const len = vec3Tmp.setFromEuler(eulerBlender).lengthSq();
            const lenAlt = vec3Tmp.setFromEuler(eulerBlenderAlt).lengthSq();
    
            dest.copy(len < lenAlt ? eulerBlender : eulerBlenderAlt);
            return transformCoordsSpace(dest, 'Y_UP_RIGHT', 'Z_UP_RIGHT');
        }
    }();
        
    function getSceneCoordSystem() {
        const scene = appInstance.scene;
        if (scene && 'coordSystem' in scene.userData) {
            return scene.userData.coordSystem;
        }
    
        return 'Y_UP_RIGHT';
    }
        
    function RotationInterface() {
        /**
         * @ignore
         * For user manipulations use XYZ extrinsic rotations (which
         * are the same as ZYX intrinsic rotations)
         *     - Blender/Max/Maya use extrinsic rotations in the UI
         *     - XYZ is the default option, but could be set from
         *       some order hint if exported
         */
        this._userRotation = new v3d.Euler(0, 0, 0, 'ZYX');
        this._actualRotation = new v3d.Euler();
    }
    
    Object.assign(RotationInterface, {
        initObject: function(obj) {
            if (obj.userData.puzzles === undefined) {
                obj.userData.puzzles = {}
            }
            if (obj.userData.puzzles.rotationInterface === undefined) {
                obj.userData.puzzles.rotationInterface = new RotationInterface();
            }
    
            const rotUI = obj.userData.puzzles.rotationInterface;
            rotUI.updateFromObject(obj);
            return rotUI;
        },
    });
    
    Object.assign(RotationInterface.prototype, {
        updateFromObject: function(obj) {
            const SYNC_ROT_EPS = 1e-8;
    
            if (!this._actualRotation.equalsEps(obj.rotation, SYNC_ROT_EPS)) {
                this._actualRotation.copy(obj.rotation);
                this._updateUserRotFromActualRot();
            }
        },
    
        getActualRotation: function(euler) {
            return euler.copy(this._actualRotation);
        },
    
        setUserRotation: function(euler) {
            // don't copy the order, since it's fixed to ZYX for now
            this._userRotation.set(euler.x, euler.y, euler.z);
            this._updateActualRotFromUserRot();
        },
    
        getUserRotation: function(euler) {
            return euler.copy(this._userRotation);
        },
    
        _updateUserRotFromActualRot: function() {
            const order = this._userRotation.order;
            this._userRotation.copy(this._actualRotation).reorder(order);
        },
    
        _updateActualRotFromUserRot: function() {
            const order = this._actualRotation.order;
            this._actualRotation.copy(this._userRotation).reorder(order);
        },
    });
        
    const Tween = (function() {
    
    var _Group=function(){this._tweens={},this._tweensAddedDuringUpdate={}};_Group.prototype={getAll:function(){return Object.keys(this._tweens).map(function(t){return this._tweens[t]}.bind(this))},removeAll:function(){this._tweens={}},add:function(t){this._tweens[t.getId()]=t,this._tweensAddedDuringUpdate[t.getId()]=t},remove:function(t){delete this._tweens[t.getId()],delete this._tweensAddedDuringUpdate[t.getId()]},update:function(t,n){var e=Object.keys(this._tweens);
    if(0===e.length)return!1;for(t=void 0!==t?t:TWEEN.now();0<e.length;){this._tweensAddedDuringUpdate={};for(var i=0;i<e.length;i++){var r=this._tweens[e[i]];r&&!1===r.update(t)&&(r._isPlaying=!1,n||delete this._tweens[e[i]])}e=Object.keys(this._tweensAddedDuringUpdate)}return!0}};var TWEEN=new _Group;TWEEN.Group=_Group,TWEEN._nextId=0,TWEEN.nextId=function(){return TWEEN._nextId++},"undefined"==typeof window&&"undefined"!=typeof process&&process.hrtime?TWEEN.now=function(){var t=process.hrtime();
    return 1e3*t[0]+t[1]/1e6}:"undefined"!=typeof window&&void 0!==window.performance&&void 0!==window.performance.now?TWEEN.now=window.performance.now.bind(window.performance):void 0!==Date.now?TWEEN.now=Date.now:TWEEN.now=function(){return(new Date).getTime()},TWEEN.Tween=function(t,n){this._object=t,this._valuesStart={},this._valuesEnd={},this._valuesStartRepeat={},this._duration=1e3,this._repeat=0,this._repeatDelayTime=void 0,this._yoyo=!1,this._isPlaying=!1,this._reversed=!1,this._delayTime=0,
    this._startTime=null,this._easingFunction=TWEEN.Easing.Linear.None,this._interpolationFunction=TWEEN.Interpolation.Linear,this._chainedTweens=[],this._onStartCallback=null,this._onStartCallbackFired=!1,this._onUpdateCallback=null,this._onCompleteCallback=null,this._onStopCallback=null,this._group=n||TWEEN,this._id=TWEEN.nextId()},TWEEN.Tween.prototype={getId:function(){return this._id},isPlaying:function(){return this._isPlaying},to:function(t,n){return this._valuesEnd=t,void 0!==n&&(this._duration=n),this},start:function(t){for(var n in this._group.add(this),this._isPlaying=!0,this._onStartCallbackFired=!1,this._startTime=void 0!==t?"string"==typeof t?TWEEN.now()+parseFloat(t):t:TWEEN.now(),this._startTime+=this._delayTime,this._valuesEnd){if(this._valuesEnd[n]instanceof Array){if(0===this._valuesEnd[n].length)continue;
    this._valuesEnd[n]=[this._object[n]].concat(this._valuesEnd[n])}void 0!==this._object[n]&&(this._valuesStart[n]=this._object[n],this._valuesStart[n]instanceof Array==!1&&(this._valuesStart[n]*=1),this._valuesStartRepeat[n]=this._valuesStart[n]||0)}return this},stop:function(){return this._isPlaying&&(this._group.remove(this),this._isPlaying=!1,null!==this._onStopCallback&&this._onStopCallback(this._object),this.stopChainedTweens()),this},end:function(){return this.update(this._startTime+this._duration),this},stopChainedTweens:function(){for(var t=0,n=this._chainedTweens.length;t<n;
    t++)this._chainedTweens[t].stop()},group:function(t){return this._group=t,this},delay:function(t){return this._delayTime=t,this},repeat:function(t){return this._repeat=t,this},repeatDelay:function(t){return this._repeatDelayTime=t,this},yoyo:function(t){return this._yoyo=t,this},easing:function(t){return this._easingFunction=t,this},interpolation:function(t){return this._interpolationFunction=t,this},chain:function(){return this._chainedTweens=arguments,this},onStart:function(t){return this._onStartCallback=t,this},onUpdate:function(t){return this._onUpdateCallback=t,this},onComplete:function(t){return this._onCompleteCallback=t,this},onStop:function(t){return this._onStopCallback=t,this},update:function(t){var n,e,i;if(t<this._startTime)return!0;
    for(n in!1===this._onStartCallbackFired&&(null!==this._onStartCallback&&this._onStartCallback(this._object),this._onStartCallbackFired=!0),e=(t-this._startTime)/this._duration,e=0===this._duration||1<e?1:e,i=this._easingFunction(e),this._valuesEnd)if(void 0!==this._valuesStart[n]){var r=this._valuesStart[n]||0,a=this._valuesEnd[n];a instanceof Array?this._object[n]=this._interpolationFunction(a,i):("string"==typeof a&&(a="+"===a.charAt(0)||"-"===a.charAt(0)?r+parseFloat(a):parseFloat(a)),"number"==typeof a&&(this._object[n]=r+(a-r)*i))}if(null!==this._onUpdateCallback&&this._onUpdateCallback(this._object),1!==e)return!0;
    if(0<this._repeat){for(n in isFinite(this._repeat)&&this._repeat--,this._valuesStartRepeat){if("string"==typeof this._valuesEnd[n]&&(this._valuesStartRepeat[n]=this._valuesStartRepeat[n]+parseFloat(this._valuesEnd[n])),this._yoyo){var s=this._valuesStartRepeat[n];this._valuesStartRepeat[n]=this._valuesEnd[n],this._valuesEnd[n]=s}this._valuesStart[n]=this._valuesStartRepeat[n]}return this._yoyo&&(this._reversed=!this._reversed),void 0!==this._repeatDelayTime?this._startTime=t+this._repeatDelayTime:this._startTime=t+this._delayTime,!0}null!==this._onCompleteCallback&&this._onCompleteCallback(this._object);for(var o=0,u=this._chainedTweens.length;o<u;o++)this._chainedTweens[o].start(this._startTime+this._duration);
    return!1}},TWEEN.Easing={Linear:{None:function(t){return t}},Quadratic:{In:function(t){return t*t},Out:function(t){return t*(2-t)},InOut:function(t){return(t*=2)<1?.5*t*t:-.5*(--t*(t-2)-1)}},Cubic:{In:function(t){return t*t*t},Out:function(t){return--t*t*t+1},InOut:function(t){return(t*=2)<1?.5*t*t*t:.5*((t-=2)*t*t+2)}},Quartic:{In:function(t){return t*t*t*t},Out:function(t){return 1- --t*t*t*t},InOut:function(t){return(t*=2)<1?.5*t*t*t*t:-.5*((t-=2)*t*t*t-2)}},Quintic:{In:function(t){return t*t*t*t*t},Out:function(t){return--t*t*t*t*t+1},InOut:function(t){return(t*=2)<1?.5*t*t*t*t*t:.5*((t-=2)*t*t*t*t+2)}},Sinusoidal:{In:function(t){return 1-Math.cos(t*Math.PI/2)},Out:function(t){return Math.sin(t*Math.PI/2)},InOut:function(t){return.5*(1-Math.cos(Math.PI*t))}},Exponential:{In:function(t){return 0===t?0:Math.pow(1024,t-1)},Out:function(t){return 1===t?1:1-Math.pow(2,-10*t)},
    InOut:function(t){return 0===t?0:1===t?1:(t*=2)<1?.5*Math.pow(1024,t-1):.5*(2-Math.pow(2,-10*(t-1)))}},Circular:{In:function(t){return 1-Math.sqrt(1-t*t)},Out:function(t){return Math.sqrt(1- --t*t)},InOut:function(t){return(t*=2)<1?-.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1)}},Elastic:{In:function(t){return 0===t?0:1===t?1:-Math.pow(2,10*(t-1))*Math.sin(5*(t-1.1)*Math.PI)},Out:function(t){return 0===t?0:1===t?1:Math.pow(2,-10*t)*Math.sin(5*(t-.1)*Math.PI)+1},InOut:function(t){return 0===t?0:1===t?1:(t*=2)<1?-.5*Math.pow(2,10*(t-1))*Math.sin(5*(t-1.1)*Math.PI):.5*Math.pow(2,-10*(t-1))*Math.sin(5*(t-1.1)*Math.PI)+1}},Back:{In:function(t){return t*t*(2.70158*t-1.70158)},Out:function(t){return--t*t*(2.70158*t+1.70158)+1},InOut:function(t){var n=2.5949095;
    return(t*=2)<1?t*t*((n+1)*t-n)*.5:.5*((t-=2)*t*((n+1)*t+n)+2)}},Bounce:{In:function(t){return 1-TWEEN.Easing.Bounce.Out(1-t)},Out:function(t){return t<1/2.75?7.5625*t*t:t<2/2.75?7.5625*(t-=1.5/2.75)*t+.75:t<2.5/2.75?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375},InOut:function(t){return t<.5?.5*TWEEN.Easing.Bounce.In(2*t):.5*TWEEN.Easing.Bounce.Out(2*t-1)+.5}}},TWEEN.Interpolation={Linear:function(t,n){var e=t.length-1,i=e*n,r=Math.floor(i),a=TWEEN.Interpolation.Utils.Linear;return n<0?a(t[0],t[1],i):1<n?a(t[e],t[e-1],e-i):a(t[r],t[e<r+1?e:r+1],i-r)},Bezier:function(t,n){for(var e=0,i=t.length-1,r=Math.pow,a=TWEEN.Interpolation.Utils.Bernstein,s=0;s<=i;s++)e+=r(1-n,i-s)*r(n,s)*t[s]*a(i,s);return e},CatmullRom:function(t,n){var e=t.length-1,i=e*n,r=Math.floor(i),a=TWEEN.Interpolation.Utils.CatmullRom;
    return t[0]===t[e]?(n<0&&(r=Math.floor(i=e*(1+n))),a(t[(r-1+e)%e],t[r],t[(r+1)%e],t[(r+2)%e],i-r)):n<0?t[0]-(a(t[0],t[0],t[1],t[1],-i)-t[0]):1<n?t[e]-(a(t[e],t[e],t[e-1],t[e-1],i-e)-t[e]):a(t[r?r-1:0],t[r],t[e<r+1?e:r+1],t[e<r+2?e:r+2],i-r)},Utils:{Linear:function(t,n,e){return(n-t)*e+t},Bernstein:function(t,n){var e=TWEEN.Interpolation.Utils.Factorial;return e(t)/e(n)/e(t-n)},Factorial:function(){var i=[1];return function(t){var n=1;if(i[t])return i[t];for(var e=t;1<e;e--)n*=e;return i[t]=n}}(),CatmullRom:function(t,n,e,i,r){var a=.5*(e-t),s=.5*(i-n),o=r*r;return(2*n-2*e+a+s)*(r*o)+(-3*n+3*e-2*a-s)*o+a*r+n}}},function(t){"function"==typeof define&&define.amd?define([],function(){return TWEEN}):"undefined"!=typeof module&&"object"==typeof exports?module.exports=TWEEN:void 0!==t&&(console.log(t),t.TWEEN=TWEEN)}(this);
    
    return TWEEN;
    })();

    return {
        getElements, getObjectByName, retrieveObjectNames, isMeshObject,
        isObjectWorthProcessing, bindListener, getSceneAnimFrameRate, getSceneByAction,
        getMaterialEditableValues, transformCoordsSpace, transformEulerV3dToBlenderShortest, getSceneCoordSystem,
        RotationInterface, Tween,
    };
};

var PL = {};



// backward compatibility
if (v3d[Symbol.toStringTag] !== 'Module') {
    v3d.PL = v3d.puzzles = PL;
}

PL.procedures = PL.procedures || {};




PL.execInitPuzzles = function(options) {
    // always null, should not be available in "init" puzzles
    var appInstance = null;
    // app is more conventional than appInstance (used in exec script and app templates)
    var app = null;

    const PzLib = createPzLib({ v3d });

    // provide the container's id to puzzles that need access to the container
    _initGlob.container = options !== undefined && 'container' in options
            ? options.container : "";

    

    // setHTMLElemStyle puzzle
function setHTMLElemStyle(prop, value, ids, isParent) {
    var elems = PzLib.getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem || !elem.style)
            continue;
        elem.style[prop] = value;
    }
}



// initSettings puzzle
_initGlob.output.initOptions.fadeAnnotations = true;
_initGlob.output.initOptions.useBkgTransp = false;
_initGlob.output.initOptions.preserveDrawBuf = false;
_initGlob.output.initOptions.useCompAssets = true;
_initGlob.output.initOptions.useFullscreen = true;

setHTMLElemStyle('backgroundColor', 'white', 'body', false);

    return _initGlob.output;
}

PL.init = function(appInstance, initOptions) {

// app is more conventional than appInstance (used in exec script and app templates)
var app = appInstance;

const PzLib = createPzLib({ v3d, appInstance });

initOptions = initOptions || {};

if ('fadeAnnotations' in initOptions) {
    _pGlob.fadeAnnotations = initOptions.fadeAnnotations;
}

this.procedures["show_cont_2"] = show_cont_2;
this.procedures["show_people"] = show_people;
this.procedures["show_cont_1"] = show_cont_1;
this.procedures["show_train"] = show_train;
this.procedures["show_near_conts"] = show_near_conts;
this.procedures["show_plane"] = show_plane;
this.procedures["animation_loops"] = animation_loops;
this.procedures["show_clouds"] = show_clouds;
this.procedures["play_animation"] = play_animation;
this.procedures["show_ship"] = show_ship;
this.procedures["time_calculate"] = time_calculate;
this.procedures["show_train_whoosh"] = show_train_whoosh;
this.procedures["scroll_animations"] = scroll_animations;
this.procedures["show_truck"] = show_truck;
this.procedures["show_animated_sea"] = show_animated_sea;
this.procedures["animated_ground"] = animated_ground;
this.procedures["train_cyrcle_movement"] = train_cyrcle_movement;
this.procedures["waving_train_sin"] = waving_train_sin;
this.procedures["mobile_version_controller"] = mobile_version_controller;
this.procedures["go_to_step"] = go_to_step;
this.procedures["rotate_interaction"] = rotate_interaction;
this.procedures["go_to"] = go_to;
this.procedures["show UI"] = show_UI;
this.procedures["show_container"] = show_container;

var PROC = {
    "show_cont_2": show_cont_2,
    "show_people": show_people,
    "show_cont_1": show_cont_1,
    "show_train": show_train,
    "show_near_conts": show_near_conts,
    "show_plane": show_plane,
    "animation_loops": animation_loops,
    "show_clouds": show_clouds,
    "play_animation": play_animation,
    "show_ship": show_ship,
    "time_calculate": time_calculate,
    "show_train_whoosh": show_train_whoosh,
    "scroll_animations": scroll_animations,
    "show_truck": show_truck,
    "show_animated_sea": show_animated_sea,
    "animated_ground": animated_ground,
    "train_cyrcle_movement": train_cyrcle_movement,
    "waving_train_sin": waving_train_sin,
    "mobile_version_controller": mobile_version_controller,
    "go_to_step": go_to_step,
    "rotate_interaction": rotate_interaction,
    "go_to": go_to,
    "show UI": show_UI,
    "show_container": show_container,
};

var VARS = Object.defineProperties({}, {
    'animation_map': { get: function() { return animation_map; }, set: function(val) { animation_map = val; } },
    'truck_details': { get: function() { return truck_details; }, set: function(val) { truck_details = val; } },
    'containers_materials': { get: function() { return containers_materials; }, set: function(val) { containers_materials = val; } },
    'containers_frames_map': { get: function() { return containers_frames_map; }, set: function(val) { containers_frames_map = val; } },
    'containers_list': { get: function() { return containers_list; }, set: function(val) { containers_list = val; } },
    'scroll_animation_list': { get: function() { return scroll_animation_list; }, set: function(val) { scroll_animation_list = val; } },
    'trains_models': { get: function() { return trains_models; }, set: function(val) { trains_models = val; } },
    'wave_train': { get: function() { return wave_train; }, set: function(val) { wave_train = val; } },
    'dust_empties': { get: function() { return dust_empties; }, set: function(val) { dust_empties = val; } },
    'dust_particles': { get: function() { return dust_particles; }, set: function(val) { dust_particles = val; } },
    'loop_calculations': { get: function() { return loop_calculations; }, set: function(val) { loop_calculations = val; } },
    'i': { get: function() { return i; }, set: function(val) { i = val; } },
    'mobile': { get: function() { return mobile; }, set: function(val) { mobile = val; } },
    'current_frame': { get: function() { return current_frame; }, set: function(val) { current_frame = val; } },
    't': { get: function() { return t; }, set: function(val) { t = val; } },
    'prev_step': { get: function() { return prev_step; }, set: function(val) { prev_step = val; } },
    'step': { get: function() { return step; }, set: function(val) { step = val; } },
    'target_frame': { get: function() { return target_frame; }, set: function(val) { target_frame = val; } },
    'loop_time': { get: function() { return loop_time; }, set: function(val) { loop_time = val; } },
    'v': { get: function() { return v; }, set: function(val) { v = val; } },
    'prev_container': { get: function() { return prev_container; }, set: function(val) { prev_container = val; } },
    'delta': { get: function() { return delta; }, set: function(val) { delta = val; } },
    'animation': { get: function() { return animation; }, set: function(val) { animation = val; } },
    'fov': { get: function() { return fov; }, set: function(val) { fov = val; } },
    'target_step': { get: function() { return target_step; }, set: function(val) { target_step = val; } },
    'x': { get: function() { return x; }, set: function(val) { x = val; } },
    'y': { get: function() { return y; }, set: function(val) { y = val; } },
});

var animation_map, x, y, truck_details, mobile, loop_calculations, i, target_step, containers_materials, prev_step, current_frame, t, target_frame, step, containers_frames_map, prev_container, loop_time, wave_train, v, containers_list, trains_models, animation, dust_empties, delta, scroll_animation_list, fov, dust_particles;

// assignAnimation puzzle
function assignAnimation(animSelector, objSelector) {
    const action = v3d.SceneUtils.getAnimationActionByName(appInstance, animSelector);
    if (action !== null) {
        const clip = action.getClip();
        const clipNew = clip.clone();

        clipNew.name = objSelector;

        for (const track of clipNew.tracks)
            track.name = track.name.replace(RegExp('^' + clip.name), clipNew.name);

        const actionNew = appInstance.mixer.clipAction(clipNew, action.getRoot());

        actionNew.setLoop(action.loop, action.repetitions, true);
        // COMPAT: always true since 4.10
        actionNew.clampWhenFinished = true;

        // if there was an action previosly assigned, replace it
        const actionReplaced = v3d.SceneUtils.getAnimationActionByName(appInstance, objSelector);
        if (actionReplaced) {
            actionReplaced.stop();
            appInstance.mixer.uncacheAction(actionReplaced.getClip(), actionReplaced.getRoot());
            appInstance.actions[appInstance.actions.indexOf(actionReplaced)] = actionNew;
        } else
            appInstance.actions.push(actionNew);

        return clipNew.name;
    }
}

// show and hide puzzles
function changeVis(objSelector, bool) {
    var objNames = PzLib.retrieveObjectNames(objSelector);

    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i]
        if (!objName)
            continue;
        var obj = PzLib.getObjectByName(objName);
        if (!obj)
            continue;
        obj.visible = bool;
        obj.resolveMultiMaterial().forEach(function(objR) {
            objR.visible = bool;
        });
    }
}

// Describe this function...
function show_cont_2() {
    if (step >= 1 && step <= 5) {
        changeVis('4', true);
        changeVis('5', true);
        changeVis('6', true);
        changeVis('container_4', true);
        changeVis('container_5', true);
        changeVis('container_6', true);
        changeVis('Harbour Crane.007', true);
        changeVis('Harbour Crane.008', true);
        changeVis('Harbour Crane.010', true);
    } else {
        changeVis('Cube.016', false);
        changeVis('Cube.026', false);
        changeVis('Cube.011', false);
        changeVis('4', false);
        changeVis('5', false);
        changeVis('6', false);
        changeVis('container_4', false);
        changeVis('container_5', false);
        changeVis('container_6', false);
    }
}

// Describe this function...
function show_people() {
    if (step >= 2 && step <= 4) {
        changeVis('People', true);
    } else {
        changeVis('People', false);
    }
}

// Describe this function...
function show_cont_1() {
    if (step <= 4) {
        changeVis('1', true);
        changeVis('2', true);
        changeVis('3', true);
        changeVis('Harbour Crane.001', true);
        changeVis('Harbour Crane.002', true);
        changeVis('Harbour Crane.004', true);
        changeVis('container_1', true);
        changeVis('container_2', true);
        changeVis('container_3', true);
    } else {
        changeVis('Harbour Crane.002', false);
        changeVis('Harbour Crane.004', false);
        changeVis('container_1', false);
        changeVis('container_2', false);
        changeVis('container_3', false);
        changeVis('Harbour Crane.001', false);
        changeVis('1', false);
        changeVis('2', false);
        changeVis('3', false);
    }
}

function getObjectsFromCollect(obj, type, nameFilterType, nameFilter, useID, out) {
    if (!PzLib.isObjectWorthProcessing(obj)) {
        return;
    }

    let doCollect = true;

    if (nameFilter) {
        switch (nameFilterType) {
        case 'NAME_EQUAL':
            if (obj.name != nameFilter)
                doCollect = false;
            break;
        case 'NAME_START':
            if (!obj.name.startsWith(nameFilter))
                doCollect = false;
            break;
        case 'NAME_END':
            if (!obj.name.endsWith(nameFilter))
                doCollect = false;
            break;
        case 'NAME_INCLUDE':
            if (!obj.name.includes(nameFilter))
                doCollect = false;
            break;
        }
    }

    if (doCollect) {
        const nameOrID = useID ? obj.uuid : obj.name;

        switch (type) {
        case 'ALL':
        case 'FIRST':
            if (out.indexOf(nameOrID) < 0)
                out.push(nameOrID);
            break;
        case 'ANNOTATION':
            if (obj.isAnnotation && out.indexOf(nameOrID) < 0)
                out.push(nameOrID);
            break;
        case 'BONE':
            if (obj.isBone && out.indexOf(nameOrID) < 0)
                out.push(nameOrID);
            break;
        case 'CAMERA':
            if (obj.isCamera && out.indexOf(nameOrID) < 0)
                out.push(nameOrID);
            break;
        case 'EMPTY':
            if (!obj.isAnnotationControl && !obj.isBone && !obj.isCamera &&
                    !obj.isGroup && !obj.isLine && !obj.isLOD && !obj.isLight &&
                    !PzLib.isMeshObject(obj) && !obj.isPoints && !obj.isScene &&
                    !obj.isSprite && out.indexOf(nameOrID) < 0)
                out.push(nameOrID);
            break;
        case 'LIGHT':
            if (obj.isLight && out.indexOf(nameOrID) < 0)
                out.push(nameOrID);
            break;
        case 'MESH':
            if (PzLib.isMeshObject(obj) && out.indexOf(nameOrID) < 0)
                out.push(nameOrID);
            break;
        default:
            console.error('get objects from puzzle: Unknown object type: ' + type);
            break;
        }
    }

    for (let i = 0; i < obj.children.length; i++) {
        const child = obj.children[i];
        getObjectsFromCollect(child, type, nameFilterType, nameFilter, useID, out);
    }
}

// getObjectsFrom puzzle
function getObjectsFrom(objSelector, type, nameFilterType, nameFilter, useID) {
    const out = [];

    const objNames = PzLib.retrieveObjectNames(objSelector);

    for (let i = 0; i < objNames.length; i++) {
        const objName = objNames[i]
        if (!objName)
            continue;

        const obj = PzLib.getObjectByName(objName);
        if (!obj)
            continue;

        getObjectsFromCollect(obj, type, nameFilterType, nameFilter, useID, out);
    }

    return (type == 'FIRST') ? out[0] : out;
}

// Describe this function...
function show_train() {
    if (step <= 1 || step >= 5) {
        changeVis(getObjectsFrom(trains_models, 'ALL', 'null', undefined, false), true);
        changeVis(getObjectsFrom(wave_train, 'ALL', 'null', undefined, false), true);
    } else {
        changeVis(getObjectsFrom(trains_models, 'ALL', 'null', undefined, false), false);
        changeVis(getObjectsFrom(wave_train, 'ALL', 'null', undefined, false), false);
    }
}

// Describe this function...
function show_near_conts() {
    if (step <= 2 || step >= 4) {
        changeVis(getObjectsFrom('hide_container', 'ALL', 'null', undefined, false), true);
    } else {
        changeVis(getObjectsFrom('hide_container', 'ALL', 'null', undefined, false), false);
    }
}

function setScreenScale(factor) {

    // already have maximum pixel ratio in HiDPI mode
    if (!appInstance.useHiDPIRenderPass)
        appInstance.renderer.setPixelRatio(factor);

    if (appInstance.postprocessing)
        appInstance.postprocessing.composer.setPixelRatio(factor);

    // to update possible post-processing passes
    appInstance.onResize();
}

// Describe this function...
function show_plane() {
    if (step >= 7 && step <= 9) {
        changeVis('Plane', true);
        changeVis('trace_plane', true);
        changeVis('Shadow_plane', true);
        changeVis('v3d_Proxy_Node_0_plane_big_swing', true);
    } else {
        changeVis('Plane', false);
        changeVis('trace_plane', false);
        changeVis('Shadow_plane', false);
        changeVis('v3d_Proxy_Node_0_plane_big_swing', false);
    }
}

_pGlob.animMixerCallbacks = [];

const initAnimationMixer = function() {

    function onMixerFinished(e) {
        const cb = _pGlob.animMixerCallbacks;
        const found = [];
        for (let i = 0; i < cb.length; i++) {
            if (cb[i][0] == e.action) {
                cb[i][0] = null; // desactivate
                found.push(cb[i][1]);
            }
        }
        for (let i = 0; i < found.length; i++) {
            found[i]();
        }
    }

    return function initAnimationMixer() {
        if (appInstance.mixer && !appInstance.mixer.hasEventListener('finished', onMixerFinished)) {
            PzLib.bindListener(appInstance.mixer, 'finished', onMixerFinished);
        }
    };

}();

// animation puzzles
function operateAnimation(operation, animations, from, to, loop, speed, callback, rev) {
    if (!animations)
        return;
    // input can be either single obj or array of objects
    if (typeof animations == "string")
        animations = [animations];

    function processAnimation(animName) {
        const action = v3d.SceneUtils.getAnimationActionByName(appInstance, animName);
        if (!action)
            return;

        let scene, frameRate, timeScale, callbacks;

        switch (operation) {
        case 'PLAY':
            if (!action.isRunning()) {
                action.reset();

                if (loop == 'AUTO') {
                    // COMPAT: < 4.10, old engine, new puzzles (no autoParams)
                    if (action.autoParams) {
                        action.loop = action.autoParams.loop;
                        action.repetitions = action.autoParams.repetitions;
                    } else {
                        action.repetitions = Infinity;
                    }
                } else {
                    action.loop = v3d[loop];
                    action.repetitions = Infinity;
                }

                scene = PzLib.getSceneByAction(action);
                frameRate = PzLib.getSceneAnimFrameRate(scene);
                timeScale = Math.abs(parseFloat(speed));

                if (rev)
                    timeScale *= -1;

                action.timeScale = timeScale;
                action.timeStart = from !== null ? from/frameRate : 0;
                if (to !== null) {
                    action.getClip().duration = to/frameRate;
                } else {
                    action.getClip().resetDuration();
                }
                action.time = timeScale >= 0 ? action.timeStart : action.getClip().duration;

                action.paused = false;
                action.play();

                // push unique callbacks only
                callbacks = _pGlob.animMixerCallbacks;
                let found = false;
                for (let j = 0; j < callbacks.length; j++)
                    if (callbacks[j][0] == action && callbacks[j][1] == callback)
                        found = true;

                if (!found)
                    _pGlob.animMixerCallbacks.push([action, callback]);
            }
            break;
        case 'STOP':
            action.stop();

            // remove callbacks
            callbacks = _pGlob.animMixerCallbacks;
            for (let j = 0; j < callbacks.length; j++)
                if (callbacks[j][0] == action) {
                    callbacks.splice(j, 1);
                    j--;
                }

            break;
        case 'PAUSE':
            action.paused = true;
            break;
        case 'RESUME':
            action.paused = false;
            break;
        case 'SET_FRAME':
            scene = PzLib.getSceneByAction(action);
            frameRate = PzLib.getSceneAnimFrameRate(scene);
            action.time = from ? from/frameRate : 0;
            action.play();
            action.paused = true;
            break;
        case 'SET_SPEED':
            timeScale = parseFloat(speed);
            action.timeScale = rev ? -timeScale : timeScale;
            break;
        }
    }

    for (let i = 0; i < animations.length; i++) {
        const animName = animations[i];
        if (animName)
            processAnimation(animName);
    }

    initAnimationMixer();
}

// setMaterialValue puzzle
function setMaterialValue(matName, valName, value) {

    var values = PzLib.getMaterialEditableValues(matName);
    if (values.indexOf(valName) < 0)
        return;

    var mats = v3d.SceneUtils.getMaterialsByName(appInstance, matName);

    for (var i = 0; i < mats.length; i++) {
        var mat = mats[i];

        if (mat.isMeshNodeMaterial) {
            var valIdx = mat.nodeValueMap[valName];
            mat.nodeValue[valIdx] = Number(value);
        } else
            mat[valName] = Number(value);

        if (appInstance.scene !== null) {
            if (mat === appInstance.scene.worldMaterial) {
                appInstance.updateEnvironment(mat);
            }
        }
    }
}

// setObjTransform puzzle
function setObjTransform(objSelector, isWorldSpace, mode, vector, offset) {
    const x = vector[0];
    const y = vector[1];
    const z = vector[2];

    if (isNaN(x) || isNaN(y) || isNaN(z)) {
        console.error('set transform puzzle: Invalid transform');
        return;
    }

    const objNames = PzLib.retrieveObjectNames(objSelector);

    function setObjProp(obj, prop, val) {
        if (!offset) {
            obj[mode][prop] = val;
        } else {
            if (mode != "scale")
                obj[mode][prop] += val;
            else
                obj[mode][prop] *= val;
        }
    }

    const inputsUsed = _pGlob.vec3Tmp.set(Number(x !== ''), Number(y !== ''), Number(z !== ''));
    const coords = _pGlob.vec3Tmp2.set(x || 0, y || 0, z || 0);

    if (mode === 'rotation') {
        // rotations are specified in degrees
        coords.multiplyScalar(v3d.MathUtils.DEG2RAD);
    }

    const coordSystem = PzLib.getSceneCoordSystem();

    PzLib.transformCoordsSpace(inputsUsed, coordSystem, 'Y_UP_RIGHT', true);
    PzLib.transformCoordsSpace(coords, coordSystem, 'Y_UP_RIGHT', mode === 'scale');

    for (let i = 0; i < objNames.length; i++) {

        const objName = objNames[i];
        if (!objName) continue;

        const obj = PzLib.getObjectByName(objName);
        if (!obj) continue;

        if (isWorldSpace && obj.parent) {
            obj.matrixWorld.decomposeE(obj.position, obj.rotation, obj.scale);

            if (inputsUsed.x) setObjProp(obj, "x", coords.x);
            if (inputsUsed.y) setObjProp(obj, "y", coords.y);
            if (inputsUsed.z) setObjProp(obj, "z", coords.z);

            obj.matrixWorld.composeE(obj.position, obj.rotation, obj.scale);
            obj.matrix.multiplyMatrices(_pGlob.mat4Tmp.copy(obj.parent.matrixWorld).invert(), obj.matrixWorld);
            obj.matrix.decompose(obj.position, obj.quaternion, obj.scale);

        } else if (mode === 'rotation' && coordSystem == 'Z_UP_RIGHT') {
            // Blender/Max coordinates

            // need all the rotations for order conversions, especially if some
            // inputs are not specified
            const euler = PzLib.transformEulerV3dToBlenderShortest(obj.rotation,
                    _pGlob.eulerTmp);
            PzLib.transformCoordsSpace(euler, coordSystem, 'Y_UP_RIGHT');

            if (inputsUsed.x) euler.x = offset ? euler.x + coords.x : coords.x;
            if (inputsUsed.y) euler.y = offset ? euler.y + coords.y : coords.y;
            if (inputsUsed.z) euler.z = offset ? euler.z + coords.z : coords.z;

            /**
             * convert from Blender/Max default XYZ extrinsic order to v3d XYZ
             * intrinsic with reversion (XYZ -> ZYX) and axes swizzling (ZYX -> YZX)
             */
            euler.order = "YZX";
            euler.reorder(obj.rotation.order);
            obj.rotation.copy(euler);

        } else if (mode === 'rotation' && coordSystem == 'Y_UP_RIGHT') {
            // Maya coordinates

            // Use separate rotation interface to fix ambiguous rotations for Maya,
            // might as well do the same for Blender/Max.

            const rotUI = PzLib.RotationInterface.initObject(obj);
            const euler = rotUI.getUserRotation(_pGlob.eulerTmp);
            // TODO(ivan): this probably needs some reasonable wrapping
            if (inputsUsed.x) euler.x = offset ? euler.x + coords.x : coords.x;
            if (inputsUsed.y) euler.y = offset ? euler.y + coords.y : coords.y;
            if (inputsUsed.z) euler.z = offset ? euler.z + coords.z : coords.z;

            rotUI.setUserRotation(euler);
            rotUI.getActualRotation(obj.rotation);
        } else {
            if (inputsUsed.x) setObjProp(obj, "x", coords.x);
            if (inputsUsed.y) setObjProp(obj, "y", coords.y);
            if (inputsUsed.z) setObjProp(obj, "z", coords.z);
        }

        obj.updateWorldMatrix(false, true);
    }

}

// Describe this function...
function animation_loops() {
    loop_calculations = (appInstance.clock.elapsedTime * 20) % 600;
    operateAnimation('SET_FRAME', 'plane_big_swing', loop_calculations, null, 'AUTO', 1, function() {}, false);
    operateAnimation('SET_FRAME', dust_empties, loop_calculations, null, 'AUTO', 1, function() {}, false);
    if (current_frame >= 350 && current_frame < 400) {
        setMaterialValue('Lighted material_rails', 'Scroll', appInstance.clock.elapsedTime * 20);
    } else {
    }
    setMaterialValue('Trace', 'Value.001', appInstance.clock.elapsedTime);
    setMaterialValue('Trace.001', 'Value.001', appInstance.clock.elapsedTime);
    setMaterialValue('whoosh', 'Value', (appInstance.clock.elapsedTime / 50) % 600);
    setObjTransform('all_rays', false, 'rotation', [0, 0, Math.min(Math.max((current_frame - 40) / (60 - 40) * (0 - 1) + 1, 0), 1) * Math.sin((10 * appInstance.clock.elapsedTime) / 180 * Math.PI) * 30], false);
    operateAnimation('SET_FRAME', 'plane_loop', loop_calculations, null, 'AUTO', 1, function() {}, false);
    setMaterialValue('Clouds', 'Value', appInstance.clock.elapsedTime / 100);
    setMaterialValue('Sea', 'Value', appInstance.clock.elapsedTime / 20);
}

// Describe this function...
function show_clouds() {
    if (step >= 4 && step <= 7) {
        changeVis('Clouds', true);
    } else {
        changeVis('Clouds', false);
    }
}

// everyFrame puzzle
function registerEveryFrame(callback) {
    if (typeof callback == 'function') {
        appInstance.renderCallbacks.push(callback);
        if (PL.editorRenderCallbacks)
            PL.editorRenderCallbacks.push([appInstance, callback]);
    }
}

// Describe this function...
function play_animation() {
    scroll_animations();
    registerEveryFrame(function() {
        time_calculate();
        animated_ground();
        train_cyrcle_movement();
        waving_train_sin();
        animation_loops();
        if (current_frame != target_frame) {
            scroll_animations();
        }
    });
}

// Describe this function...
function show_ship() {
    if (step <= 1 || current_frame >= 6) {
        changeVis('Ship', true);
        changeVis('Shadow_plane.001', true);
    } else {
        changeVis('Ship', false);
        changeVis('Shadow_plane.001', false);
    }
}

// Describe this function...
function time_calculate() {
    if (current_frame < target_frame) {
        current_frame = current_frame + delta;
        if (target_frame - current_frame == 20) {
            prev_step = step;
            step = target_step;
            show_UI();
        }
        if (animation == 0) {
            animation = 1;
        }
    } else {
        if (current_frame > target_frame) {
            if (current_frame - target_frame == 20) {
                prev_step = step;
                step = target_step;
                show_UI();
            }
            current_frame = current_frame - delta;
            if (animation == 0) {
                animation = 1;
            }
        } else {
            if (animation == 1) {
                prev_step = step;
                animation = 0;
            }
        }
    }
    if (current_frame >= 284 && current_frame < 420) {
        loop_time = 500;
    } else {
        loop_time = appInstance.clock.elapsedTime * 8;
    }
}

// Describe this function...
function show_train_whoosh() {
    if (step >= 5 && step <= 6) {
        changeVis(getObjectsFrom('whoosh_train', 'ALL', 'null', undefined, false), true);
    } else {
        changeVis(getObjectsFrom('whoosh_train', 'ALL', 'null', undefined, false), false);
    }
}

// Describe this function...
function scroll_animations() {
    mobile_version_controller();
    operateAnimation('SET_FRAME', wave_train, current_frame, null, 'AUTO', 1, function() {}, false);
    operateAnimation('SET_FRAME', truck_details, current_frame, null, 'AUTO', 1, function() {}, false);
    operateAnimation('SET_FRAME', containers_materials, current_frame, null, 'AUTO', 1, function() {}, false);
    operateAnimation('SET_FRAME', containers_list, current_frame, null, 'AUTO', 1, function() {}, false);
    operateAnimation('SET_FRAME', dust_particles, current_frame, null, 'AUTO', 1, function() {}, false);
    operateAnimation('SET_FRAME', scroll_animation_list, current_frame, null, 'AUTO', 1, function() {}, false);
}

// Describe this function...
function show_truck() {
    if (step >= 4 && step <= 6) {
        changeVis(getObjectsFrom(truck_details, 'ALL', 'null', undefined, false), true);
    } else {
        changeVis(getObjectsFrom(truck_details, 'ALL', 'null', undefined, false), false);
    }
}

// Describe this function...
function show_animated_sea() {
    if (step <= 1 || step >= 6) {
        changeVis('Sea', true);
    } else {
        changeVis('Sea', false);
    }
}

// Describe this function...
function animated_ground() {
    if (current_frame > 308 && current_frame < 460) {
        setMaterialValue('ground noise', 'Value', appInstance.clock.elapsedTime);
    }
}

// Describe this function...
function train_cyrcle_movement() {
    var i_end = trains_models.length - 1;
    var i_inc = 1;
    if (0 > i_end) {
        i_inc = -i_inc;
    }
    for (let i = 0; i_inc >= 0 ? i <= i_end : i >= i_end; i += i_inc) {
        t = (loop_time + i * 4) % 600;
        operateAnimation('SET_FRAME', trains_models[i], t, null, 'AUTO', 1, function() {}, false);
    }
}

// Describe this function...
function waving_train_sin() {
    if (step >= 5 && step <= 7) {
        var i_end2 = wave_train.length - 1;
        var i_inc2 = 1;
        if (0 > i_end2) {
            i_inc2 = -i_inc2;
        }
        for (let i = 0; i_inc2 >= 0 ? i <= i_end2 : i >= i_end2; i += i_inc2) {
            v = Math.sin((appInstance.clock.elapsedTime * 1000 + i * 1000) / 180 * Math.PI) / 1000;
            setObjTransform(wave_train[i], false, 'position', [v, v, 0], true);
            setObjTransform(wave_train[i], false, 'rotation', [v, 0, 0], true);
        }
    }
}

// getObjTransform puzzle
function getObjTransform(objName, isWorldSpace, mode, coord) {
    if (!objName)
        return;
    var obj = PzLib.getObjectByName(objName);
    if (!obj)
        return;

    var coordSystem = PzLib.getSceneCoordSystem();

    var transformVal;

    if (isWorldSpace && obj.parent) {
        if (mode === 'position') {
            transformVal = PzLib.transformCoordsSpace(
                    obj.getWorldPosition(_pGlob.vec3Tmp), 'Y_UP_RIGHT',
                    coordSystem, mode === 'scale');
        } else if (mode === 'rotation') {
            transformVal = PzLib.transformCoordsSpace(
                    obj.getWorldEuler(_pGlob.eulerTmp, 'XYZ'), 'Y_UP_RIGHT',
                    coordSystem, mode === 'scale');
        } else if (mode === 'scale') {
            transformVal = PzLib.transformCoordsSpace(
                    obj.getWorldScale(_pGlob.vec3Tmp), 'Y_UP_RIGHT',
                    coordSystem, mode === 'scale');
        }

    } else if (mode === 'rotation' && coordSystem == 'Z_UP_RIGHT') {
        transformVal = PzLib.transformEulerV3dToBlenderShortest(obj.rotation,
                _pGlob.eulerTmp);

    } else if (mode === 'rotation' && coordSystem == 'Y_UP_RIGHT') {
        // Maya coordinates
        // Use separate rotation interface to fix ambiguous rotations for Maya,
        // might as well do the same for Blender/Max.

        var rotUI = PzLib.RotationInterface.initObject(obj);
        transformVal = rotUI.getUserRotation(_pGlob.eulerTmp);

    } else {
        transformVal = PzLib.transformCoordsSpace(obj[mode].clone(),
                'Y_UP_RIGHT', coordSystem, mode === 'scale');
    }

    if (mode === 'rotation') {
        transformVal.x = v3d.MathUtils.radToDeg(transformVal.x);
        transformVal.y = v3d.MathUtils.radToDeg(transformVal.y);
        transformVal.z = v3d.MathUtils.radToDeg(transformVal.z);
    }

    if (coord == 'xyz') {
        // remove order component for Euler vectors
        return transformVal.toArray().slice(0, 3);
    } else {
        return transformVal[coord];
    }
}

// setCameraParam puzzle
function setCameraParam(type, camSelector, param) {

    const camNames = PzLib.retrieveObjectNames(camSelector);

    camNames.forEach(function(camName) {
        if (!camName)
            return;

        var cam = PzLib.getObjectByName(camName);
        if (!cam || !cam.isCamera) return;

        if (!(cam.isPerspectiveCamera || cam.isOrthographicCamera)) {
            console.error('set camera param puzzle: Incompatible camera type, have to be perspective or orthographic');
            return;
        }

        let isSetOrbitParam = false;
        let isSetFirstpersonParam = false;

        switch (type) {
            case 'ORBIT_MIN_DISTANCE_PERSP':
            case 'ORBIT_MAX_DISTANCE_PERSP':
            case 'ORBIT_MIN_ZOOM_ORTHO':
            case 'ORBIT_MAX_ZOOM_ORTHO':
            case 'ORBIT_MIN_VERTICAL_ANGLE':
            case 'ORBIT_MAX_VERTICAL_ANGLE':
            case 'ORBIT_MIN_HORIZONTAL_ANGLE':
            case 'ORBIT_MAX_HORIZONTAL_ANGLE':
            case 'ORBIT_ALLOW_TURNOVER':
            case 'SCREEN_SPACE_PANNING':
                isSetOrbitParam = true;
                break;
            case 'ENABLE_COLLISIONS':
                isSetFirstpersonParam = true;
                break;
        }

        let isSetControlsParam = (['ROTATION_SPEED', 'MOVEMENT_SPEED', 'ALLOW_PANNING', 'ALLOW_ZOOM', 'ALLOW_CTRL_ZOOM', 'KEYBOARD_CONTROLS'].includes(type) || isSetOrbitParam || isSetFirstpersonParam);

        if (isSetControlsParam) {
            if (!cam.controlSettings) {
                console.error('set camera param puzzle: The "' + camName +'" camera has no control settings assigned');
                return;
            } else if ((isSetOrbitParam && cam.controlSettings.type != 'ORBIT') ||
                    (isSetFirstpersonParam && cam.controlSettings.type != 'FIRST_PERSON')) {
                console.error('set camera param puzzle: Incompatible camera controls: ' + cam.controlSettings.type);
                return;
            }
        }

        switch (type) {
            case 'FIELD_OF_VIEW':
                if (cam.isPerspectiveCamera) {
                    cam.fov = param;
                    cam.updateProjectionMatrix();
                } else {
                    console.error('set camera param puzzle: Incompatible camera type, have to be perspective');
                    return;
                }
                break;
            case 'ORTHO_SCALE':
                if (cam.isOrthographicCamera) {
                    cam.zoom = param;
                    cam.updateProjectionMatrix();
                } else {
                    console.error('set camera param puzzle: Incompatible camera type, have to be orthographic');
                    return;
                }
                break;
            case 'ROTATION_SPEED':
                cam.controlSettings.rotateSpeed = param;
                break;
            case 'MOVEMENT_SPEED':
                cam.controlSettings.moveSpeed = param;
                break;
            case 'ALLOW_PANNING':
                cam.controlSettings.enablePan = param;
                break;
            case 'ALLOW_ZOOM':
                cam.controlSettings.enableZoom = param;
                break;
            case 'ALLOW_CTRL_ZOOM':
                cam.controlSettings.enableCtrlZoom = param;
                break;
            case 'KEYBOARD_CONTROLS':
                cam.controlSettings.enableKeys = param;
                break;
            case 'ORBIT_MIN_DISTANCE_PERSP':
                if (cam.isPerspectiveCamera) {
                    cam.controlSettings.orbitMinDistance = param;
                } else {
                    console.error('set camera param puzzle: Incompatible camera type, have to be perspective');
                    return;
                }
                break;
            case 'ORBIT_MAX_DISTANCE_PERSP':
                if (cam.isPerspectiveCamera) {
                    cam.controlSettings.orbitMaxDistance = param;
                } else {
                    console.error('set camera param puzzle: Incompatible camera type, have to be perspective');
                    return;
                }
                break;
            case 'ORBIT_MIN_ZOOM_ORTHO':
                if (cam.isOrthographicCamera) {
                    cam.controlSettings.orbitMinZoom = param;
                } else {
                    console.error('set camera param puzzle: Incompatible camera type, have to be orthographic');
                    return;
                }
                break;
            case 'ORBIT_MAX_ZOOM_ORTHO':
                if (cam.isOrthographicCamera) {
                    cam.controlSettings.orbitMaxZoom = param;
                } else {
                    console.error('set camera param puzzle: Incompatible camera type, have to be orthographic');
                    return;
                }
                break;
            case 'ORBIT_MIN_VERTICAL_ANGLE':
                cam.controlSettings.orbitMinPolarAngle = v3d.MathUtils.degToRad(param);
                break;
            case 'ORBIT_MAX_VERTICAL_ANGLE':
                cam.controlSettings.orbitMaxPolarAngle = v3d.MathUtils.degToRad(param);
                break;
            case 'ORBIT_MIN_HORIZONTAL_ANGLE':
                cam.controlSettings.orbitMinAzimuthAngle = v3d.MathUtils.degToRad(param);
                break;
            case 'ORBIT_MAX_HORIZONTAL_ANGLE':
                cam.controlSettings.orbitMaxAzimuthAngle = v3d.MathUtils.degToRad(param);
                break;
            case 'ORBIT_ALLOW_TURNOVER':
                cam.controlSettings.orbitEnableTurnover = param;
                break;
            case 'SCREEN_SPACE_PANNING':
                cam.controlSettings.screenSpacePanning = param;
                break;
            case 'ENABLE_COLLISIONS':
                cam.controlSettings.enableCollisions = param;
                break;
            case 'CLIP_START':
                cam.near = param;
                cam.updateProjectionMatrix();
                break;
            case 'CLIP_END':
                cam.far = param;
                cam.updateProjectionMatrix();
                break;
        }

        if (isSetControlsParam)
            appInstance.enableControls();

    });
}

// Describe this function...
function mobile_version_controller() {
    if (mobile == 1) {
        setObjTransform('Interaction root', false, 'position', ['', '', getObjTransform('adaptive_scale_control', false, 'position', 'x')], false);
        setCameraParam('FIELD_OF_VIEW', 'Camera.Main', getObjTransform('adaptive_scale_control', false, 'scale', 'x') * fov);
    }
}

// Describe this function...
function go_to_step(x) {
    target_step = x;
    target_frame = animation_map[x];
    step = x;
    current_frame = animation_map[x];
    scroll_animations();
    show_UI();
}

// Describe this function...
function rotate_interaction(x, y) {
    setObjTransform('Interaction root', false, 'rotation', [y, 0, x], false);
}

// Describe this function...
function go_to(x) {
    if (step + x < animation_map.length && step + x >= 0) {
        target_step = step + x;
    }
    target_frame = animation_map[target_step];
}

// Describe this function...
function show_UI() {
    console.log(step);
    console.log(prev_step);
}

// animateParam puzzle
function tweenUpdateCb() {
    PzLib.Tween.update();
}
appInstance.renderCallbacks.push(tweenUpdateCb);
if (PL.editorRenderCallbacks)
    PL.editorRenderCallbacks.push([appInstance, tweenUpdateCb]);

// animateParam puzzle
_pGlob.animateParamUpdate = 0;
_pGlob.animateParamTweenInstance = {};

function animateParam(from, to, duration, easing, easing2, repeat, yoyo, blockId, on_update, when_finished) {

    var mode = easing == "Linear" ?
        PzLib.Tween.Easing.Linear.None : PzLib.Tween.Easing[easing][easing2];

    var tweenObject = (typeof from != "number");

    if (!tweenObject) { // number
        from = [from];
        to = [to];
    }

    const tween = new PzLib.Tween.Tween(from)
                    .to(to, duration * 1000)
                    .easing(mode)
                    .repeat(repeat)
                    .yoyo(yoyo)
                    .onUpdate(function (object) {
                        if (tweenObject)
                            _pGlob.animateParamUpdate = object;
                        else // number
                            _pGlob.animateParamUpdate = object[0];
                        on_update();
                    })
                    .onComplete(function (object) {
                        when_finished();
                    })
                    .start();

    _pGlob.animateParamTweenInstance[blockId] = tween;
}

// Describe this function...
function show_container(x) {
    if (prev_container != x) {
        if (prev_container > -1) {

            animateParam(0, 5, 0.5, 'Quintic', 'InOut', 0, false, 'HGiV[OrsY?2#gEYEoB4U',
                function() {
                setObjTransform(containers_list[prev_container], false, 'position', [0, 0, (_pGlob.animateParamUpdate || 0) / 1000], true);
            },
                function() {
                prev_container = -1;
            });

                }

        animateParam(0, 5, 0.5, 'Quintic', 'InOut', 0, false, 'CI?aWh*cYCDR__u7Am0)',
            function() {
            setObjTransform(containers_list[x], false, 'position', [0, 0, (_pGlob.animateParamUpdate || 0) / -1000], true);
        },
            function() {
            prev_container = x;
        });

            }
}


animation_map = [0, 60, 120, 180, 220, 310, 380, 460, 530, 600];
truck_details = ['Truck', 'Truck_wheels', 'Truck_wheels.001', 'Truck_wheels.002', 'Truck_wheels.006', 'Truck_wheels.007', 'Shadow_plane.002', 'whoosh_truck', 'trace_truck'];
containers_materials = ['container_1', 'container_2', 'container_3', 'container_4', 'container_5', 'container_6'];
containers_frames_map = [0, 62, 150];
containers_list = ['Harbour Crane.001', 'Harbour Crane.002', 'Harbour Crane.004', 'Harbour Crane.007', 'Harbour Crane.010', 'Harbour Crane.008'];
scroll_animation_list = ['road', 'bat_logo', 'Cube', 'Land', 'Shadow_plane.002', 'Shadow_plane.001', 'Shadow_plane', 'adaptive_scale_control', '1', '2', '3', '4', '5', '6', 'Circle.001', 'People', 'whoosh_truck', 'whoosh_train', 'plane_big_appiarance', 'Animation root', 'Distant root', 'ray_1', 'ray_2', 'Dust', 'Harbour Crane', 'track.001', 'plane_small_position', 'train_traces', 'Truck CLOSE', 'Empty.004', 'Empty', 'Ship', 'ray_geometry_1', 'Sea', 'ray_geometry_2', 'ground noise', 'Clouds', 'trace_truck', 'trace_plane', 'bat_logo', 'Plane'];
trains_models = [assignAnimation('Cycled train motion', 't-p-14'), assignAnimation('Cycled train motion', 't-p-13'), assignAnimation('Cycled train motion', 't-p-12'), assignAnimation('Cycled train motion', 't-p-11'), assignAnimation('Cycled train motion', 't-p-10'), assignAnimation('Cycled train motion', 't-p-9'), assignAnimation('Cycled train motion', 't-p-8'), assignAnimation('Cycled train motion', 't-p-7'), assignAnimation('Cycled train motion', 't-p-6'), assignAnimation('Cycled train motion', 't-p-5'), assignAnimation('Cycled train motion', 't-p-4'), assignAnimation('Cycled train motion', 't-p-3'), assignAnimation('Cycled train motion', 't-p-2'), assignAnimation('Cycled train motion', 't-p-1'), assignAnimation('Cycled train motion', 't-p-0')];
wave_train = ['train cart.014', 'train cart.013', 'train cart.012', 'train cart.011', 'train cart.010', 'train cart.009', 'train cart.008', 'train cart.007', 'train cart.006', 'train cart.005', 'train cart.004', 'train cart.003', 'train cart.002', 'train cart.001', 'train'];
dust_empties = ['Empty_dust.001', 'Empty_dust.002', 'Empty_dust.003', 'Empty_dust.004', 'Empty_dust.005', 'Empty_dust.006', 'Empty_dust.007', 'Empty_dust.008', 'Empty_dust.009', 'Empty_dust.010', 'Empty_dust.011', 'Empty_dust.012', 'Empty_dust.013', 'Empty_dust.014', 'Empty_dust.015', 'Empty_dust.016', 'Empty_dust.017', 'Empty_dust.018', 'Empty_dust.019', 'Empty_dust.020', 'Empty_dust.021', 'Empty_dust.022', 'Empty_dust.023', 'Empty_dust.024', 'Empty_dust.025', 'Empty_dust.026', 'Empty_dust.027', 'Empty_dust.028'];
dust_particles = ['Circle.008', 'Circle.009', 'Circle.010', 'Circle.011', 'Circle.012', 'Circle.013', 'Circle.014', 'Circle.015', 'Circle.016', 'Circle.017', 'Circle.018', 'Circle.019', 'Circle.020', 'Circle.021', 'Circle.022', 'Circle.023', 'Circle.024', 'Circle.025', 'Circle.026', 'Circle.027', 'Circle.028', 'Circle.029', 'Circle.006', 'Circle.001', 'Circle.002', 'Circle.003', 'Circle.004', 'Circle.005', 'Circle.007'];

if (window.devicePixelRatio > 1) {
    setScreenScale((window.devicePixelRatio - 1) * 0.35 + 1);
}
mobile = 0;
prev_step = 0;
prev_container = -1;
animation = 0;
delta = 0.5;
step = 0;
target_step = 0;
target_frame = 0;
current_frame = 0;

Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('' + '\n' +
' let w = VARS[\'w\'] = window.innerWidth;' + '\n' +
' let h = VARS[\'h\'] = window.innerHeight;' + '\n' +
'    ' + '\n' +
'if(w/h<1.78){VARS[\'fov\'] = h/w * 31.5 + 5.378}' + '\n' +
'if(w/h<1){' + '\n' +
'    VARS[\'mobile\'] = 1' + '\n' +
'    VARS[\'delta\'] = 1' + '\n' +
'    ' + '\n' +
'}' + '\n' +
'  ' + '\n' +
'' + '\n' +
'')))(appInstance, v3d, PL, VARS, PROC);

play_animation();


Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('/*document.addEventListener(\'keydown\', (event) => {' + '\n' +
'  const key = event.key;' + '\n' +
'' + '\n' +
'  if (key === \'ArrowLeft\' || key === \'a\' || key === \'A\') {' + '\n' +
'        puzzles.procedures[\'go_to\'](-1);' + '\n' +
'  } else if (key === \'ArrowRight\' || key === \'d\' || key === \'D\') {' + '\n' +
'        puzzles.procedures[\'go_to\'](1);' + '\n' +
'  } else if (key === \'ArrowUp\' || key === \'w\' || key === \'W\') {' + '\n' +
'      ' + '\n' +
'  } else if (key === \'ArrowDown\' || key === \'s\' || key === \'S\') {' + '\n' +
'       ' + '\n' +
'  } else if (/^[0-9]$/.test(key)) { ' + '\n' +
'    //    09 go_to_step' + '\n' +
'    puzzles.procedures.show_container(parseInt(key, 10));' + '\n' +
'    console.log(parseInt(key, 10))' + '\n' +
'  }' + '\n' +
'});*/')))(appInstance, v3d, PL, VARS, PROC);



Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('document.addEventListener(\'mousemove\', (event) => {' + '\n' +
'  const screenWidth = window.innerWidth;' + '\n' +
'  const screenHeight = window.innerHeight;' + '\n' +
'' + '\n' +
'  const centerX = screenWidth / 2;' + '\n' +
'  const centerY = screenHeight / 2;' + '\n' +
'' + '\n' +
'  //    ' + '\n' +
'  const offsetX = centerX - event.clientX;' + '\n' +
'  const offsetY = centerY - event.clientY;' + '\n' +
'' + '\n' +
'  //    [-1, 1]' + '\n' +
'  const normalizedX = offsetX / (screenWidth / 2);' + '\n' +
'  const normalizedY = offsetY / (screenHeight / 2);' + '\n' +
'' + '\n' +
'  //  ' + '\n' +
'  const clampedX = Math.max(-1, Math.min(1, normalizedX));' + '\n' +
'  const clampedY = Math.max(-1, Math.min(1, normalizedY));' + '\n' +
'' + '\n' +
'  //     ' + '\n' +
'  puzzles.procedures[\'rotate_interaction\'](clampedX , clampedY);' + '\n' +
'});')))(appInstance, v3d, PL, VARS, PROC);



} // end of PL.init function

PL.disposeListeners = function() {
    if (_pGlob) {
        _pGlob.eventListeners.forEach(({ target, type, listener, optionsOrUseCapture }) => {
            target.removeEventListener(type, listener, optionsOrUseCapture);
        });
        _pGlob.eventListeners.length = 0;
    }
}

PL.disposeHTMLElements = function() {
    if (_pGlob) {
        _pGlob.htmlElements.forEach(elem => {
            elem.remove();
        });
        _pGlob.htmlElements.clear();
    }
}

PL.disposeMaterialsCache = function() {
    if (_pGlob) {
        for (const mat of _pGlob.materialsCache.values()) {
            mat.dispose();
        }
        _pGlob.materialsCache.clear();
    }
}

PL.dispose = function() {
    PL.disposeListeners();
    PL.disposeHTMLElements();
    PL.disposeMaterialsCache();
    _pGlob = null;
    // backward compatibility
    if (v3d[Symbol.toStringTag] !== 'Module') {
        delete v3d.PL;
        delete v3d.puzzles;
    }
}



return PL;

}

export { createPL };
